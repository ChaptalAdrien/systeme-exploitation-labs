# LAB 3 - Virtual Memory

in this lab, we have impplemented a virtual memory system in language C.

Here is how we managed it : 

## Memory structure

```
// the memory to manage + its related management data
// SIZE in our case is 2^20

typedef struct {
    int v_mem[SIZE];
    bool index[SIZE];
    // add here anything needed to manage v_mem
} mem_t;
```

The  memory is composed of two Array : 
- v_mem : an array where we will write words inside (the words have int size)
- Index : a boolean array that we will use to manage if a memory emplacement is available or not

## Functions

### initContMem

```
mem_t initContem(){
    mem_t mem;
    
    mem.v_mem = {NULL};
    mem.index = {0};

    return *mem;
}
```
This function just initialize the array in memory properly, so that every word is null and every space is not allocated.

### myContAlloc (mem, nb_of_words_to_allocate)

```
int myContAlloc(mem_t mem, int word_size){
    int free = 0;
    int adress;
    
    //For in mem array to find enought contiguous places for our word
    for(int i=0, i < SIZE - 1, i= i + word_size){
        if(mem.index[i] = 0){
            free++;
            if(free >= word_size){
                adress = i - word_size;
                for(int j = adress, j <= i, j++){
                    mem.index[j] = {1};
                }
                break;
            }
        }else {
            free = 0;
        }
    }
    return adress;
}
```

This function allocates contiguous/consecutive space inside the memory. We've implemented the method "first fit", which means that the memory will be allocated as the first place in the array where there is enough space. This isn't the most optimized way to manage memory allocation so we can still improve on that point. 

Once the contigious words in memory are declared used in the "mem.index" array, we return the base adress (adress of the first word).

### myContFree (mem, base_address, nb_of_words_to_free_up_from_base_address)

```
void myContFree(mem_t mem,int adr, int nb_words){
    for(int i=0; i<nb_words; i++){
        mem.index[adr + i] = 0;
    }
}
```

In this function we just declare a number of word including the base address free. To do that we just set 0 to those adresses  in the array "index".

### myWrite(mem, address, value)

```
void myContWrite(mem_t mem, int adr, int n){

    if(mem.index[adr] = 1){   
        input = s    
        mem.v_mem[adr] = n;
    }else{
        printf("This memory space isn't allocated :  wrinting impossible  ");
    }
}
```

This function is pretty simple to, we just insert the specified value inside our memory array at the  specified address. However, we need to check if the memory emplacement is declared used in the index array.

### myRead(mem, address)

```
int myContRead(memt mem, int adr)
{
    if(mem.index[adr] ==  1){
        return mem.v_mem[adr];
    }else{
        printf("This memory space isn't allocated")
        return 0;
    }
}
```

This function simply return the word inside the memory at the specified adress. Accordingly to the previous function, we check if the space is allocated before reading it.

## Conclusion

