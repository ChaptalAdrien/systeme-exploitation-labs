#include <stdlib.h> 
#include <stdio.h>

const int SIZE = 2^(20);

// the memory to manage + its related management data
// SIZE in our case is 2^20
typedef struct {
    int v_mem[SIZE];
    int index[SIZE];
    // add here anything needed to manage v_mem
} mem_t;

//typedef struct address_t int; // weâ€™ll be using address_t from now on when using addresses

mem_t initContem(){
    mem_t mem;
    
    mem.v_mem = {NULL};
    mem.index = {0};

    return *mem;
}

int myContAlloc(mem_t mem, int word_size){
    int free = 0;
    int adress;
    
    //For in mem array to find enought contiguous places for our word
    for(int i=0, i < SIZE - 1, i= i + word_size){
        if(mem->index[i] = 0){
            free++;
            if(free >= word_size){
                adress = i - word_size;
                for(int j = adress, j <= i, j++){
                    mem->index[j] = {1};
                }
                break;
            }
        }else {
            free = 0;
        }
    }
    return adress;
}

void myContFree(mem_t mem,int adr, int words){
    for(int i=0; i<words; i++){
        mem.index[adr + i] = 0;
    }
}


int main() {
    mem_t *mem = initContem(); // create the memory space and intialize properly its management area
    int adr1= myContAlloc (mem, 5); // allocate 5 words from mem
    int adr2 = myContAlloc(mem, 10); // allocate 10 words from mem
    int adr3= myContAlloc(mem, 100); // allocate 100 words from mem
    myContFree (mem, adr2, 10); // release the 10 words allocated in line 14
    myContFree (mem, adr3, 5); // release the 5 words allocated in line 13
    myContWrite(mem, adr3, 543); // write on the 1st word of the memory allocated in Line 15
    myContWrite(mem, adr3+9, 34); // write on the 10th word of the memory allocated in Line 15
    int val1 = myContRead(mem, adr3); // read the 1st word
    int val2 = myContRead (mem, adr3+9); // read the 10th word
}


 