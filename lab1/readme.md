# LAB 1

## Authors

Adrien Chaptal
Gael Rousseau

## 1 - Creating and Running a Process (1) - fork

### 1.1 & 1.2

Fork creates a new process by duplicating the calling process. This new process is refferenced as the "child process".

The child process has a unique PID, different from his parent process.

fork() returns the PID of the child process in the parent process, and 0 in the child process.

### 1.3 Parent Child Program

see code file

### 1.4 

```
int i = 5;
if (fork() == 0)
{ 
// I’m the child
    i++;
    printf("%d\n", i); //I added this line to verify that this line was indeed executed
} else {
    // I’m the parent process 
    sleep(3); // sleep for 3 seconds ; why ?
    printf("%d\n", i); }
```

If we compile and run this code (see full code here), it outputs :
```
6
5
```
You can see that the condition if(fork()=0) is true inside the child process.

### 1.5 

See this code.

## 2 - Creating and running a process (2) - exec 

### 2.1 

The  exec()  family  of functions replaces the current process image with a new process image.

There are several functions from this family :
```
    int execl(char const *path, char const *arg0, ...);
    int execle(char const *path, char const *arg0, ..., char const *envp[]);
    int execlp(char const *file, char const *arg0, ...);
    int execv(char const *path, char const *argv[]);
    int execve(char const *path, char const *argv[], char const *envp[]);
    int execvp(char const *file, char const *argv[]);
    int fexecve(int fd, char *const argv[], char *const envp[]);
```

The base of each is exec (execute), followed by one or more letters:

    e – An array of pointers to environment variables is explicitly passed to the new process image.
    l – Command-line arguments are passed individually (a list) to the function.
    p – Uses the PATH environment variable to find the file named in the file argument to be executed.
    v – Command-line arguments are passed to the function as an array (vector) of pointers.

### 2.2

We use execvp(*char[]) to execute a program.

## 2.3

a - Yes, we can put arguments for our new program executed. 

We can see in this image that the file "toto.txt" was indeed created.

b - Yes 

c - For exemple, i've modified this line of code from 2.2 :
```
char *args[]={"/bin/touch","toto.txt",NULL};
```

## 2.4

```
int i = 5;
if (fork()== 0){
    // Exec call
    char *args[]={"/bin/gimp-2.10",NULL};
    execv(args[0],args);

    //the new process replace this one, so following statements will not be executed untill previous execution is done
    i++;
    printf("%d\n", i); 
} else {
    // display process id
    printf("Process ID : %d\n", getpid());
}
```

### 3. Simple Shell

```
int main(){

    pid_t pid;
    char input[100];
    int returnStatus;

    //Infinite loop to keep the shell running
    while(1==1){
        //Wait for child to finish
        waitpid(pid, &returnStatus, 0);

        //read user prompt
        printf("SimpleShell>");
        if(fgets(input,sizeof(input),stdin) == NULL){
            printf("*** ERROR: read prompt failed\n");
            perror("fgets");
            exit(1);
        }else{
            //Exit the shell if user prompt exit
            if(strcmp(input,"exit\n")==0){
                exit(0);
            }else if(input != ""){
                //Removing \n at the end of input
                for(int i=(sizeof(input) -1); i!=-1; i--){
                    if(input[i]=='\n'){
                        input[i] = '\0';    
                    }
                }
                //execute commande in child process
                pid = fork();
                if(pid == 0){
                    //execute command
                    char *args[]={input,NULL};
                    if (execvp(args[0],args) < 0) {     
                        printf("*** ERROR: exec failed\n");
                        perror("execvp");
                        exit(1);
                    }
                }else if(pid == -1){
                    printf("*** ERROR: fork() failed\n");
                    perror("fork");
                    exit(1);        
                }
            }
        }
    }
    return 0;
}
```

