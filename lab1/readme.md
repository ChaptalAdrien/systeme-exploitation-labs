# LAB 1

## Authors

Adrien Chaptal
Gael Rousseau

## 1 - Creating and Running a Process (1) - fork

### 1.1 & 1.2

Fork creates a new process by duplicating the calling process. This new process is refferenced as the "child process".

The child process has a unique PID, different from his parent process.

fork() returns the PID of the child process in the parent process, and 0 in the child process.

### 1.3 Parent Child Program

see code file

### 1.4 

```
int i = 5;
if (fork() == 0)
{ 
// I’m the child
    i++;
    printf("%d\n", i); //I added this line to verify that this line was indeed executed
} else {
    // I’m the parent process 
    sleep(3); // sleep for 3 seconds ; why ?
    printf("%d\n", i); }
```

If we compile and run this code (see full code here), it outputs :
```
6
5
```
You can see that the condition if(fork()==0) is true inside the child process.

### 1.5 

See this code.

## 2 - Creating and running a process (2) - exec 

### 2.1 

The  exec()  family  of functions replaces the current process image with a new process image.

There are several functions from this family :
```
    int execl(char const *path, char const *arg0, ...);
    int execle(char const *path, char const *arg0, ..., char const *envp[]);
    int execlp(char const *file, char const *arg0, ...);
    int execv(char const *path, char const *argv[]);
    int execve(char const *path, char const *argv[], char const *envp[]);
    int execvp(char const *file, char const *argv[]);
    int fexecve(int fd, char *const argv[], char *const envp[]);
```

The base of each is exec (execute), followed by one or more letters:

    e – An array of pointers to environment variables is explicitly passed to the new process image.
    l – Command-line arguments are passed individually (a list) to the function.
    p – Uses the PATH environment variable to find the file named in the file argument to be executed.
    v – Command-line arguments are passed to the function as an array (vector) of pointers.

### 2.2

We use execvp(*char[]) to execute a program.

## 2.3

a - The new process replace the "parent" and therefore ovewrite the memomory. So there is no data shared between the two process. But you can pass arguments to your binary with the exec function (see 2.3.c). 

b - Yes, copying and pasting for exemple.

c - For exemple, i've modified this line of code from 2.2 :
```
char *args[]={"/bin/touch","toto.txt",NULL};
```

We can see that the file toto.txt was indeed created with the exec() call.

## 2.4

```
int i = 5;
if (fork()== 0){
    // Exec call
    char *args[]={"/bin/gimp-2.10",NULL};
    execv(args[0],args);

    //the new process replace this one, so following statements will not be executed
    i++;
    printf("%d\n", i); 
} else {
    // display process id
    printf("Process ID : %d\n", getpid());
}
```

The new process created by the exec call replace the old one, so in the child the instructions after the exec call will not be executed.

### 3. Simple Shell

To make a shell, we need to read the user input and then execute it with an exec function. The problem is that the executed process will *replace* the shell process , so when this process is stopped, so is our shell.

To remediate to that, we need to fork() our shell and execute the user input inside the child. Therefore, when the executed process is completed, the child is kill but our shell is still running.


See the code here :
```
int main(){

    pid_t pid;
    char input[100];
    int returnStatus;

    //Infinite loop to keep the shell running
    while(1==1){
        //read user prompt
        printf("SimpleShell>");
        if(fgets(input,sizeof(input),stdin) == NULL){
            printf("*** ERROR: read prompt failed\n");
            perror("fgets");
            exit(1);
        }else{
            //Exit the shell if user prompt exit
            if(strcmp(input,"exit\n") == 0){
                exit(0);
            }else if (strcmp(input,"\n") != 0){
                //Removing \n at the end of input
                for(int i=(sizeof(input) -1); i!=-1; i--){
                    if(input[i]=='\n'){
                        input[i] = '\0';    
                    }
                }
                //execute commande in child process
                pid = fork();
                if(pid == 0){
                    //execute command
                    char *args[]={input,NULL};
                    if (execvp(args[0],args) < 0) {     
                        printf("*** ERROR: exec failed\n");
                        perror("execvp");
                        exit(1);
                    }
                }else if(pid == -1){
                    printf("*** ERROR: fork() failed\n");
                    perror("fork");
                    exit(1);        
                }
            }
        }
        //Wait for child to finish
        waitpid(pid, &returnStatus, 0);
    }
    return 0;
}
```

